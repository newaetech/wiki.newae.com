This tutorial will introduce you to breaking devices by determining when a device is performing certain operations. It will use a simple password check, and demonstrate how to perform a basic power analysis.

In addition this example shows you how to drive the ChipWhisperer software with a script, rather than using the GUI. This will be required when attacking new devices which you have not yet added to the core ChipWhisperer software.

Note this is not a prerequisite to the tutorial on breaking AES. You can skip this tutorial if you wish to go ahead with the AES tutorial.

You can also view a 53-min [https://www.youtube.com/watch?v=h4eAU6vEONs&hd=1 Video Version on YouTube]:

= Prerequisites =

You should have already completed tutorialtimingsimple to gain a better understanding of the ChipWhisperer interface.

= Building the Target Firmware =

The target firmware is located in the directory <code>chipwhisperer\hardware\victims\firmware\basic-passwdcheck</code>. Build the firmware using <code>make</code>, once again being careful to ensure you have modified the <code>makefile</code> to select the correct target. You should end up with something like this being printed:

<pre>Creating Symbol Table: basic-passwdcheck.sym
avr-nm -n basic-passwdcheck.elf &gt; basic-passwdcheck.sym

Size after:
AVR Memory Usage
----------------
Device: atxmega128d3

Program:    5400 bytes (3.9% Full)
(.text + .data + .bootloader)

Data:        524 bytes (6.4% Full)
(.data + .bss + .noinit)


Built for platform CW-Lite XMEGA

-------- end --------</pre>
= Manual Communications with the Target =

At this point, you should be able to configure the target as in the previous tutorials. Rather than tediously going through the setup process again, we'll simply use one of the scripts built into the ChipWhisperer-Capture software. This will demonstrate how we can use a script as a starting point to simplify our setup.

<ol style="list-style-type: decimal;">
<li>Connect your target hardware (ChipWhisperer-Lite or ChipWhisperer-Capture Rev 2 with target board).</li>
<li>Open the ChipWhisperer-Capture software.</li>
<li>From the ''Example Scripts'', select one which most closely matches your hardware. For example here I'm using a ChipWhisperer-Lite with the XMEGA target, so will select that script. Note I'm ''NOT'' attacking AES, so will need to make some adjustments later. .. image:: /images/tutorials/basic/timingpowerbasic/scriptexample.png</li>
<li>The system should connect to your hardware. Remember you have not yet reprogrammed the target so won't be communicating with the target program.</li>
<li>Using the programming tool (such as XMEGA programming dialog), program the file <code>basic-passwdcheck.hex</code> into the target device. This file is located where you ran <code>make</code> previously.</li>
<li><p>Select ''Tools --&gt; Open Terminal'', and press ''Connect''. You should see a window such as this:</p>
<blockquote><p>[[File:Termconn.png|image]]</p></blockquote></li>
<li><p>At this point we need to reset the target device. The easiest way to do this is use the programmer interface, and press the ''Check Signature'' or ''Read Signature'' button. This will reset the target device as part of the signature read operation. You should see some messages come across the terminal emulator window:</p>
<blockquote><p>[[File:Checksig_print.png|image]]</p></blockquote>
<dl>
<dt>Note a few warnings about the terminal emulator:</dt>
<dd><ul>
<li>The on-board buffer is fairly small, and can be easily overflowed. You may notice a few longer lines become trunicated if printing is too fast!</li>
<li>You can uncheck the &quot;Show non-ASCII as hex&quot; to avoid having the <code>0a</code> printed in red. The <code>0a</code> is the hex character for a newline. Many protocols use non-ASCII characters, so to help with debugging it is left enabled by default.</li></ul>
</dd></dl>
</li>
<li><p>We've now got some super-secure system! Let's begin with some exploratory tests - in this case I happened to know the correct password is <code>h0px3</code>.</p>
<blockquote><p>'''tip'''</p>
<p>In real systems, you may often know ''one'' of the passwords, which is sufficient to investigate the password checking routines as we will do. You also normally have an ability to reset passwords to default. While the reset procedure would erase any data you care about, the attacker will be able to use this 'sacrificial' device to learn about possible vulnerabilites. So the assumption that we have access to the password is really just saying we have access to ''a'' password, and will use that knowledge to break the system in general.</p></blockquote></li>
<li><p>Using the terminal emulator, write the correct password in, and press <code>&lt;enter&gt;</code>. You should be greeted by a welcome message, and if using the CW-Lite XMEGA target the green LED will illuminate:</p>
<p>[[File:Passok.png|image]]</p></li>
<li>The system enters an infinite loop for any password entry. Thus you must reset the system, use the ''Programmer Window'' to again perform a ''Check Signature'' or ''Read Signature'' operation.</li>
<li>Enter an incorrect password - notice a different message is printed, and if using the CW-Lite XMEGA target the red LED will come on.</li></ol>


= Recording Power Traces =
Now that we can communicate with our super-secure system, our next goal is to get a power trace while the target is running. To do this, we'll get the power measurements to trigger after we send our password to the target. 

<ol style="list-style-type: decimal;">
<li><p>We'll make some changes to the trigger setup of the ChipWhisperer. In particular, ensure you set the following:</p>
<blockquote><ul>
<li>Offset = 0</li>
<li>Timeout set to 5 seconds or greater (to give yourself time when manually testing)</li></ul>

<p>[[File:Timeout_offset.png|image]]</p></blockquote></li>
<li><p>Change to the ''Target Settings'' tab, and delete the ''Command'' strings. Those strings are used in the AES attack to send a specific command to the target device, for now we will be manually sending data:</p>
<blockquote><p>[[File:Text_targetsettings.png|image]]</p></blockquote></li>

<li><p>Perform the following actions:</p>
<blockquote><ol style="list-style-type: lower-roman;">
<li>Reset the target device (e.g. by performing the signature check).</li>
<li>Enter the password <code>h0px3</code> in the terminal window, but ''do not'' yet hit enter.</li>
<li>Press the ''Capture 1'' button, and immediately switch to the terminal emulator window and press <code>&lt;enter&gt;</code> to send the password.</li></ol>
</blockquote>
<p>You must send the password before the timeout occurs -- you can increase the length of the timeout if needed to give yourself more time! If this works you should see the power consumption displayed in the GUI:</p>
<blockquote><p>[[File:Trace_manual_pass.png|image]]</p></blockquote></li>

<li><p>Rather than using the manual terminal, let's now use the GUI to automatically send a password try. Switching back to the ''Target Settings'' tab, write <code>h0px3\n</code> into the ''Go Command'' option:</p>
<blockquote><p>[[File:Gocorrect.png|image]]</p></blockquote>
<p>The ''Go Command'' is sent right after the scope is armed. In this example it means we can capture the power consumption during the password entry phase.</p></li>
<li><p>Now perform the following actions:</p>
<blockquote><ol style="list-style-type: lower-roman;">
<li>Reset the target device (e.g. by performing the signature check).</li>
<li>Press the ''Capture 1'' button.</li></ol>
</blockquote>
<p>Hopefully this resulted in the same waveform as before! Note the device takes around 1 second to 'boot', so if you are too lightning fast after resetting the device it won't actually be ready to accept the password. You can keep the terminal emulator window open to view the output data.</p></li>
<li><p>Play around with the password entered on the ''Go Command'' - try all of the following:</p>
<ul>
<li><code>h0px3\n</code></li>
<li><code>h0px4\n</code></li>
<li><code>h0paa\n</code></li>
<li><code>haaaa\n</code></li>
<li><code>a\n</code></li></ul>

<p>You should notice a distinct change in the password depending how many characters were correct. For example the following shows the difference between passwords of <code>h0px4</code> (which has 4 correct characters) and <code>h0paa</code> (which has 3 correct characters):</p>
<blockquote><p>[[File:3vs4.png|image]]</p></blockquote></li></ol>



= Automatic Resets =
The last step before scripting an entire attack is to figure out how to automatically reset the target device before (or after) each capture. There are two ways to do this, and the following steps take you through two examples of how to accomplish this goal.

== Reset via Spare IO Lines ==

TODO - see reset via programming interface for now

== Reset via Auxiliary Module ==

Auxiliary modules are small pieces of code that can perform some extra functions during the capture process. The functions inside these Python modules are run before a capture, before the power measurement is armed, before the measurement is triggered, after a single trace is completed, and after an entire capture is finished. We will use an existing auxiliary module to reset the target chip before arming the measurement so that we don't have to manually reset the device.

<ol style="list-style-type: decimal;">
<li> We're going to use the ''Reset AVR/XMEGA via CW-Lite'' auxiliary module. Let's get an idea of how this module works: 
* Navigate to the auxiliary modules folder (<code>chipwhisperer\software\chipwhisperer\capture\auxiliary\</code>) and open <code>ResetCW1183Read.py</code> in your choice of text editor.
* Find the function definition for <code>resetDevice()</code>. It contains a line that looks like: 
<pre>
CWCoreAPI.getInstance().getScope().scopetype.cwliteXMEGA.readSignature()
</pre>
* Look for the lines where this function gets called. You'll find that the function <code>traceArm()</code> uses it like:  
<pre>
resettiming = self.findParam('resettiming').value()
if resettiming == 'Pre-Arm':
    self.resetDevice()
</pre>
Effectively, this code will read the target's signature before we arm the power measurement. This means that the target will automatically be reset before capturing a power trace.
</li>

<li> Go back to the ChipWhisperer Capture software. In the ''Generic Settings'' tab, switch the Auxiliary Module to ''Reset AVR/XMEGA via CW-Lite''.
</li>
<li> Now, in the ''Aux Settings'' tab, we can configure our automatic reset. Make sure the settings are:
* Pre-arm delay: roughly 1200 ms
* Post-arm delay: the default (0 ms) is fine
* Reset timing: Pre-arm (reset the device before we arm the scope)
</li>
<li> Press ''Capture 1''. The target will automatically reset, with the Safe-o-matic 3000 boot sequence appearing in the console. Then, 1 second later, the program will send the password to the target and record a power trace.
</li>
</ol>

Now, confirm that you can try different passwords (in ''Target Settings'') and see how the power trace changes when your password has 0, 1, 2... correct characters.

= Scripting Communications =

<ol style="list-style-type: decimal;">
<li>Make a copy of the existing script. You can find it at <code>chipwhisperer\software\chipwhisperer\capture\scripts</code>, for example the default one is called <code>cwlite-simpleserialxmega.py</code> for the XMEGA device. Copy this to another directory that you will use for the attack.</li>
<li><p>Rename the script something else - for example <code>cwlite-passwordcrack.py</code>, and open it for editing. You'll notice the following is a main chunk of the code, where the parameters are set:</p>
<pre>#Example of using a list to set parameters. Slightly easier to copy/paste in this format
lstexample = [['CW Extra', 'CW Extra Settings', 'Trigger Pins', 'Target IO4 (Trigger Line)', True],
              ['CW Extra', 'CW Extra Settings', 'Target IOn Pins', 'Target IO1', 'Serial RXD'],
              ['CW Extra', 'CW Extra Settings', 'Target IOn Pins', 'Target IO2', 'Serial TXD'],
              ['OpenADC', 'Clock Setup', 'CLKGEN Settings', 'Desired Frequency', 7370000.0],
              ['CW Extra', 'CW Extra Settings', 'Target HS IO-Out', 'CLKGEN'],
              ['OpenADC', 'Clock Setup', 'ADC Clock', 'Source', 'CLKGEN x4 via DCM'],
              ['OpenADC', 'Trigger Setup', 'Total Samples', 3000],
              ['OpenADC', 'Trigger Setup', 'Offset', 1500],
              ['OpenADC', 'Gain Setting', 'Setting', 45],
              ['OpenADC', 'Trigger Setup', 'Mode', 'rising edge'],
              #Final step: make DCMs relock in case they are lost
              ['OpenADC', 'Clock Setup', 'ADC Clock', 'Reset ADC DCM', None],
              ]</pre>
<p>Those parameters come from the ''Scripting Parameters'' tab. Switch over to it and notice how when you change the text for example, it tells you the required parameter name to do this via the API call:</p>
<blockquote><p>[[File:Scriptcommands.png|image]]</p></blockquote>
<p>Note that commands run via the script are also printed, so you can see where the values being set are coming from too. At this point close the ''ChipWhisperer-Capture'' window, as we will confirm the script still works.</p></li>
<li><p>Run the new script (which doesn't have any changes yet). You may have to open a console with Python in the path:</p>
<blockquote><ol style="list-style-type: lower-roman;">
<li>If you installed WinPython, run the ''WinPython Console'' from your WinPython installation directory.</li>
<li>If using the VMWare image of a Linux machine, this should just be a regular console</li></ol>
</blockquote></li></ol>

<blockquote>Run the script with <code>python cwlite-passwordcrack.py</code>. If the script errors out, it might be that the location of the FPGA bitstream is stored in relative terms. To fix this perform the following:

<blockquote><ol style="list-style-type: lower-roman;">
<li>Open ChipWhisperer-Capture regularly.</li>
<li>Run the ChipWhisperer script that you used previously.</li>
<li>Select ''Tools--&gt;Config CW Firmware''</li>
<li>Under the &quot;FPGA .zip (Release)&quot;, hit the &quot;Find&quot; button. Point the system to the file <code>chipwhisperer/hardware/capture/chipwhisperer-lite/cwlite_firmware.zip</code> on your filesystem. Note by default there is a relative path.</li></ol>
</blockquote></blockquote>
<ol start="4" style="list-style-type: decimal;">
<li>Once again on the ''Target Settings'' tab, delete the various commands. Note the resulting ''Script Commands'' which you will need to enter to achieve this same goal.</li>
<li>Close ChipWhisperer-Capture.</li>
<li><p>Edit the script, first find the line setting the Trigger Offset:</p>
<pre>['OpenADC', 'Trigger Setup', 'Offset', 1500],</pre>
<p>And set this to 0, which we were using previously:</p>
<pre>['OpenADC', 'Trigger Setup', 'Offset', 0],</pre></li>
<li><p>Next, append the required commands to clear the simpleserial commands:</p>
<pre>#Example of using a list to set parameters. Slightly easier to copy/paste in this format
lstexample = [['CW Extra', 'CW Extra Settings', 'Trigger Pins', 'Target IO4 (Trigger Line)', True],
              ...BUNCH MORE COMMANDS HERE HAVE BEEN REMOVED...
              #Final step: make DCMs relock in case they are lost
              ['OpenADC', 'Clock Setup', 'ADC Clock', 'Reset ADC DCM', None],

              #Append your commands here
              ['Target Connection', 'Load Key Command', u''],
              ['Target Connection', 'Go Command', u''],
              ['Target Connection', 'Output Format', u''],                      
              ]</pre></li>
<li><p>Next, we are going to &quot;hack in&quot; the Auxiliary module. While the following isn't great Python code, the idea is to demonstrate how we can rapidly iterate with the combination of GUI to explore options, and the script to write them into place. First, add the imports to the start of the Python script:</p>
<pre>from time import sleep
from chipwhisperer.capture.auxiliary.AuxiliaryTemplate import AuxiliaryTemplate</pre>
<p>Find the section of the file that sends the previous commands to the hardware. You will see a line like the following:</p>
<pre>#Download all hardware setup parameters
for cmd in lstexample: cap.setParameter(cmd)</pre>
<p>We will then hack in the script we tested previously, which will insert our custom Auxiliary module:</p>
<pre>#Download all hardware setup parameters
for cmd in lstexample: cap.setParameter(cmd)

def reset_device():
    cap.scope.scopetype.cwliteXMEGA.readSignature()
    sleep(0.8)

class resetClass(AuxiliaryTemplate):
  def traceDone(self):
   reset_device()

rc = resetClass()
cap.auxChanged(rc)</pre>
<p>Note we changed the references to &quot;self&quot; to &quot;cap&quot;, as we are no longer running from within the Capture environment. Otherwise we have used the ability of Python to declare classes inside of functions to avoid needing to think about how to properly declare everything.</p></li>
<li><p>Finally, we will set the password. You can enter the password in the Capture ''Target Settings'' tab, and see the following sort of call would set the appropriate password:</p>
<pre>cap.setParameter(['Target Connection', 'Go Command', u'h0px3\\n'])</pre>
<p>Note the newline is actually escaped, to set the text equivalent of what will be printed. This will result in an actual newline going out across the serial port.</p>
<p>Set that command at some point after your call to <code>cap.auxChanged()</code>. Close any open ChipWhisperer-Capture windows, and run the script as before. You should connect to the target, and be able to press ''Capture 1'' and see the correct waveform.</p></li>
<li><p>Next, we will automatically start attacking the system. You needed to figure out where we will look to determine if the password check is working. Looking at an example of the power when 0 and 1 bytes are correct, we can see a good point that appears to shift forward in time:</p>
<blockquote><p>[[File:Passwordcrackerpts.png|image]]</p></blockquote>
<p>This point corresponds to an offset of 153 samples, and a delta for each character of 72 points. Note the specific point will change for different hardware, and may also change if you use different versions of avr-gcc to compile the target code. The example code here was compiled with WinAVR 20100110, which has avr-gcc 4.3.3. If you view the video version of this tutorial the point numbers are different for example, so be sure to check what they are for your specific system.</p>
<p>Let's start with cracking just the first character, assuming it's a lowercase alphanumeric character:</p>
<pre>trylist = &quot;abcdefghijklmnopqrstuvwyx0123456789&quot;

for c in trylist:
    cap.setParameter(['Target Connection', 'Go Command', u'%c\\n'%c])
    cap.capture1()

    #TODO: Check data to see if successful??
    print &quot;Try = %c&quot;%c

    #Call to pe() causes GUI to process outstanding events, useful if you are calling API directly
    pe()</pre></li>
<li>We haven't yet pragmatically tested the results, but run the script anyway (to kill it, you'll have to use Ctrl-C on the terminal window). You should notice a distinct change of the power signature when it runs through &quot;Try = h&quot;.</li>
<li><p>We can access <code>cap.scope.datapoints</code> to get the data points. Let's print that point of interest (again change the point for your specific setup):</p>
<pre>for c in trylist:
    cap.setParameter(['Target Connection', 'Go Command', u'%c\\n'%c])
    cap.capture1()

    #TODO: Check data to see if successful??
    print &quot;Try = %c&quot;%c
    print cap.scope.datapoints[153]

    #Call to pe() causes GUI to process outstanding events, useful if you are calling API directly
    pe()</pre></li>
<li><p>Running that example, you can see we can use a simple threshold to detect the correct password. Finally use the following paying careful attention that you first:</p>
<blockquote><ul>
<li>Check the offset and delta values (here they are 153 and 72)</li>
<li>Note that the &quot;Go Command&quot; has been modified to send the known password characters, otherwise it won't work in a progressive manner.</li></ul>
</blockquote>
<p>The following is a sample code you can replace the previous with:</p>
<pre>password = &quot;&quot;

for i in range(0,5):
    print &quot;***CHARACTER %d***&quot;%i
    for c in trylist:
        cap.setParameter(['Target Connection', 'Go Command', password + &quot;%c\\n&quot;%c])
        cap.capture1()

        print &quot;Try = %c&quot;%c
        #print cap.scope.datapoints[153 + i*72]
        if cap.scope.datapoints[153 + i*72] &gt; -0.2:
            print &quot;****CHARACTER %d = %c****&quot;%(i, c)
            password += c
            break

        elif c == &quot;9&quot;:
            print &quot;****CHARACTER %d FAILED****&quot;%(i)
            password += &quot;?&quot;

        #Call to pe() causes GUI to process outstanding events, useful if you are calling API directly
        pe()    

print password</pre></li></ol>

That's it! You should have successfully cracked a password using the timing attack. Some notes on this method:

<blockquote>* The target device has a finite start-up time, which slows down the attack. If you wish, remove some of the printf()'s from the target code, recompile and reprogram, and see how quickly you can do this attack.
* The current script doesn't look for the &quot;WELCOME&quot; message when the password is OK. That is an extension that allows it to crack any size password.
* If there was a lock-out on a wrong password, the system would ignore it, as it resets the target after every attempt.
</blockquote>
= Conclusion =

This tutorial has demonstrated the use of the power side-channel for performing timing attacks. A target with a simple password-based security system is broken. In addition you have learned about the scripting support in the ChipWhisperer-Capture software.

[[Category:Tutorial]]
