= Block Cipher Modes =

In the real world, it's a bad idea to encrypt data directly using block ciphers like AES. The goal of encryption is to produce ciphertexts that look pseudo-random: there should be no visible patterns in the output. Using a block cipher directly, encrypting the same plaintext multiple times will always result in the same ciphertext, so any patterns in the input will also appear in the output. This encryption method is called the ''Electronic Code Book'' (ECB) block cipher mode. 

[[File:Block-Cipher-ECB.png]]

To get around the weaknesses of ECB mode, there are alternative encryption methods that reuse the basic block ciphers and their core. A number of these are described [https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation on Wikipedia]. On top of ECB mode, there are 4 more block cipher modes that this attack will consider.

'''Cipher Block Chaining (CBC):''' The plaintext is XORed with the previous ciphertext before being encrypted. There is no ciphertext before the first plaintext, so a randomly chosen initialization vector (IV) is used instead:

[[File:Block-Cipher-CBC.png]]

'''Cipher Feedback (CFB):''' The previous ciphertext is used as the input for the cipher. Then, the plaintext is XORed with the result to get the new ciphertext. Again, an IV is used to replace the missing ciphertext:

[[File:Block-Cipher-CFB.png]]

'''Output Feedback (OFB):''' An IV is repeatedly encrypted to produce a pseudo-random sequence of blocks. Then, these encryption results are XORed with the plaintexts to produce the ciphertexts:

[[File:Block-Cipher-OFB.png]]

'''Counter (CTR):''' An incrementing counter is encrypted to produce a sequence of blocks, which are XORed with the plaintexts to produce the ciphertexts:

[[File:Block-Cipher-CTR.png]]

All four of these modes share the same quality: if the same plaintext block is encrypted multiple times, the result will be different every time. The goal of this attack is to take a target that's using one of these five cipher modes and determine which mode is being used.


= Firmware =
To perform this attack, the SimpleSerial AES XMEGA firmware was modified to allow the target to use all five of these block cipher modes. The <code>encrypt()</code> function takes a new plaintext and produces the next ciphertext:

<pre>
void encrypt(uint8_t* pt)
{
	static uint8_t input[16];
	static uint8_t output[16];
	
	// Find input 
	switch(BLOCK_MODE)
	{
		case ECB:
			for(int i = 0; i < 16; i++)
				input[i] = pt[i];
			break;
			
		case CBC:
			for(int i = 0; i < 16; i++)
				input[i] = pt[i] ^ ct[i];
			break;
			
		case CFB:
			for(int i = 0; i < 16; i++)
				input[i] = ct[i];
			break;
			
		case OFB:
			for(int i = 0; i < 16; i++)
				input[i] = output[i];
			break;
			
		case CTR:
			input[0]++;
			break;
	}
	
	// Encrypt in place
	for(int i = 0; i < 16; i++)
		output[i] = input[i];
	aes_indep_enc(output);
	
	// Use output to calculate new ciphertext
	switch(BLOCK_MODE)
	{
		case ECB:
		case CBC:
			for(int i = 0; i < 16; i++)
				ct[i] = output[i];
			break;
			
		case CFB:
		case OFB:
		case CTR:
			for(int i = 0; i < 16; i++)
				ct[i] = output[i] ^ pt[i];
			break;
	}
}
</pre>

Check that all five of these modes match the diagrams above. Note that there is no way to select an IV in this code - the contents of <code>ct[]</code> are not fixed when the target is powered on. However, the IV isn't important for these attacks, so this limitation isn't a big deal.

This code was compiled five times with five different values of <code>BLOCK_MODE</code>, producing five hex files (one for ECB encryption, one for CBC, etc). All of this code is in the ChipWhisperer repository under <code>chipwhisperer\hardware\victims\firmware\simpleserial-aes-modes\</code>.
